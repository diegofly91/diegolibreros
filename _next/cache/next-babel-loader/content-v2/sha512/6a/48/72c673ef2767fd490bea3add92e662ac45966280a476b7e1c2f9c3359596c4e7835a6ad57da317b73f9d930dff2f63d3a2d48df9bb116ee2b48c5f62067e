{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useState, useEffect } from \"react\";\nimport { Grid } from \"@material-ui/core\";\nimport makeStyles from \"@material-ui/core/styles/makeStyles\";\nimport { DragDropContext, resetServerContext } from \"react-beautiful-dnd\";\nimport Column from \"./column\";\nimport NewBtnItem from './newItem';\nconst useStyles = makeStyles(theme => ({\n  container: {\n    position: 'relative',\n    margin: '20px 0px'\n  }\n}));\n\nconst Prueba = () => {\n  const classes = useStyles();\n  const {\n    0: columns,\n    1: setColumns\n  } = useState(initialColumns);\n  useEffect(() => {\n    resetServerContext();\n  }, []);\n\n  const onDragEnd = ({\n    source,\n    destination\n  }) => {\n    // Make sure we have a valid destination\n    if (destination === undefined || destination === null) return null; // Make sure we're actually moving the item\n\n    if (source.droppableId === destination.droppableId && destination.index === source.index) return null; // Set start and end variables\n\n    const start = columns[source.droppableId];\n    const end = columns[destination.droppableId]; // If start is the same as end, we're in the same column\n\n    if (start === end) {\n      // Move the item within the list\n      // Start by making a new list without the dragged item\n      console.log(start);\n      const newList = start.list.filter((_, idx) => idx !== source.index); // Then insert the item at the right location\n\n      newList.splice(destination.index, 0, start.list[source.index]); // Then create a new copy of the column object\n\n      const newCol = {\n        id: start.id,\n        list: newList\n      }; // Update the state\n\n      setColumns(state => _objectSpread(_objectSpread({}, state), {}, {\n        [newCol.id]: newCol\n      }));\n      return null;\n    } else {\n      // If start is different from end, we need to update multiple columns\n      // Filter the start list like before\n      const newStartList = start.list.filter((_, idx) => idx !== source.index); // Create a new start column\n\n      const newStartCol = {\n        id: start.id,\n        list: newStartList\n      }; // Make a new end list array\n\n      const newEndList = end.list; // Insert the item into the end list\n\n      newEndList.splice(destination.index, 0, start.list[source.index]); // Create a new end column\n\n      const newEndCol = {\n        id: end.id,\n        list: newEndList\n      }; // Update the state\n\n      setColumns(state => _objectSpread(_objectSpread({}, state), {}, {\n        [newStartCol.id]: newStartCol,\n        [newEndCol.id]: newEndCol\n      }));\n      return null;\n    }\n  };\n\n  const addItem = async ({\n    title,\n    description,\n    column\n  }) => {\n    let idHigher = 0;\n    Object.values(columns).map(item => {\n      item.list.map(item2 => {\n        if (Number(item2.id) >= idHigher) {\n          idHigher = Number(item2.id) + 1;\n        }\n      });\n    });\n    column.list.unshift({\n      id: String(idHigher),\n      text: title,\n      description\n    });\n    const newEndCol = {\n      id: column.id,\n      list: column.list\n    };\n    setColumns(state => _objectSpread(_objectSpread({}, state), {}, {\n      [newEndCol.id]: newEndCol\n    }));\n    return null;\n  };\n\n  return __jsx(DragDropContext, {\n    onDragEnd: onDragEnd\n  }, __jsx(Grid, {\n    container: true,\n    direction: \"row\",\n    justify: \"center\"\n  }, Object.values(columns).map(column => {\n    return __jsx(Grid, {\n      item: true,\n      xs: 12,\n      md: 4,\n      className: classes.container,\n      key: column.id\n    }, __jsx(NewBtnItem, {\n      addItem: addItem,\n      column: column,\n      key: `${column.id}-btn`\n    }), __jsx(Column, {\n      column: column,\n      key: column.id\n    }));\n  })));\n};\n\nexport default Prueba;\nconst initialColumns = {\n  todo: {\n    id: \"todo\",\n    list: [{\n      id: \"1\",\n      text: \"text1\",\n      description: \" — I'll be in your neighborhood doing errands this… 1\"\n    }, {\n      id: \"2\",\n      text: \"text2\",\n      description: \" — I'll be in your neighborhood doing errands this… 2\"\n    }, {\n      id: \"3\",\n      text: \"text3\",\n      description: \" — I'll be in your neighborhood doing errands this… 3\"\n    }]\n  },\n  doing: {\n    id: \"doing\",\n    list: [{\n      id: \"4\",\n      text: \"text4\",\n      description: \" — I'll be in your neighborhood doing errands this… 4\"\n    }, {\n      id: \"5\",\n      text: \"text5\",\n      description: \" — I'll be in your neighborhood doing errands this… 5\"\n    }, {\n      id: \"6\",\n      text: \"text6\",\n      description: \" — I'll be in your neighborhood doing errands this… 6\"\n    }]\n  },\n  done: {\n    id: \"done\",\n    list: []\n  }\n};","map":null,"metadata":{},"sourceType":"module"}